import { type IField } from '@noble/curves/abstract/modular';
import { poseidon } from '@noble/curves/abstract/poseidon';
import type { Hex } from '@noble/curves/abstract/utils';
import * as u from '@noble/curves/abstract/utils';
import { type CurveFn, type ProjConstructor, type ProjPointType, type SignatureConstructor, type SignatureType } from '@noble/curves/abstract/weierstrass';
type ProjectivePoint = ProjPointType<bigint>;
export declare const MAX_VALUE: bigint;
export declare const _starkCurve: CurveFn;
export declare function normalizePrivateKey(privKey: Hex): string;
export declare function getPublicKey(privKey: Hex, isCompressed?: boolean): Uint8Array;
export declare function getSharedSecret(privKeyA: Hex, pubKeyB: Hex): Uint8Array;
export declare function sign(msgHash: Hex, privKey: Hex, opts?: any): SignatureType;
export declare function verify(signature: SignatureType | Hex, msgHash: Hex, pubKey: Hex): boolean;
declare const CURVE: Readonly<import('@noble/curves/abstract/curve').BasicCurve<bigint> & {
    a: bigint;
    b: bigint;
    allowedPrivateKeyLengths?: readonly number[];
    wrapPrivateKey?: boolean;
    endo?: {
        beta: bigint;
        splitScalar: (k: bigint) => {
            k1neg: boolean;
            k1: bigint;
            k2neg: boolean;
            k2: bigint;
        };
    };
    isTorsionFree?: ((c: import('@noble/curves/abstract/weierstrass').ProjConstructor<bigint>, point: ProjPointType<bigint>) => boolean) | undefined;
    clearCofactor?: ((c: import('@noble/curves/abstract/weierstrass').ProjConstructor<bigint>, point: ProjPointType<bigint>) => ProjPointType<bigint>) | undefined;
} & {
    hash: u.CHash;
    hmac: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;
    randomBytes: (bytesLength?: number) => Uint8Array;
    lowS?: boolean;
    bits2int?: (bytes: Uint8Array) => bigint;
    bits2int_modN?: (bytes: Uint8Array) => bigint;
} & {
    nByteLength: number;
    nBitLength: number;
}>;
declare const ProjectivePoint: ProjConstructor<bigint>;
declare const Signature: SignatureConstructor;
declare const utils: {
    normPrivateKeyToScalar: (key: u.PrivKey) => bigint;
    isValidPrivateKey(privateKey: u.PrivKey): boolean;
    randomPrivateKey: () => Uint8Array;
    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;
};
export { CURVE, ProjectivePoint, Signature, utils };
export declare function grindKey(seed: Hex): string;
export declare function getStarkKey(privateKey: Hex): string;
export declare function ethSigToPrivate(signature: string): string;
export declare function getAccountPath(layer: string, application: string, ethereumAddress: string, index: number): string;
type PedersenArg = Hex | bigint | number;
export declare function pedersen(x: PedersenArg, y: PedersenArg): string;
export declare const computeHashOnElements: (data: PedersenArg[], fn?: typeof pedersen) => PedersenArg;
export declare const keccak: (data: Uint8Array) => bigint;
export declare const Fp251: Readonly<IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>>;
export declare function _poseidonMDS(Fp: IField<bigint>, name: string, m: number, attempt?: number): bigint[][];
export type PoseidonOpts = {
    Fp: IField<bigint>;
    rate: number;
    capacity: number;
    roundsFull: number;
    roundsPartial: number;
};
export type PoseidonFn = ReturnType<typeof poseidon> & {
    m: number;
    rate: number;
    capacity: number;
};
export declare function poseidonBasic(opts: PoseidonOpts, mds: bigint[][]): PoseidonFn;
export declare function poseidonCreate(opts: PoseidonOpts, mdsAttempt?: number): PoseidonFn;
export declare const poseidonSmall: PoseidonFn;
export declare function poseidonHash(x: bigint, y: bigint, fn?: PoseidonFn): bigint;
export declare function poseidonHashFunc(x: Uint8Array, y: Uint8Array, fn?: PoseidonFn): Uint8Array;
export declare function poseidonHashSingle(x: bigint, fn?: PoseidonFn): bigint;
export declare function poseidonHashMany(values: bigint[], fn?: PoseidonFn): bigint;
//# sourceMappingURL=index.d.ts.map